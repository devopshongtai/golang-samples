{
	"01-module": {
		"scope": "go",
		"prefix": "go",
		"body": [
			"package main",
			"",
			"import (",
			"\t\"fmt\"",
			"",
			"\t\"github.com/mbndr/figlet4go\"",
			"\t\"rsc.io/quote\"",
			")",
			"",
			"func main() {",
			"\tascii := figlet4go.NewAsciiRender()",
			"\trenderStr, _ := ascii.Render(quote.Hello())",
			"",
			"\tfmt.Print(renderStr)",
			"}"
		],
		"description": "Go Module Demo"
	},
	"02-Dockerfile": {
		"prefix": "go",
		"body": [
			"# Use a multi-stage build",
			"FROM golang:latest AS builder",
			"",
			"# Compile Go into exe",
			"WORKDIR /app",
			"COPY . .",
			"# Note that linker flags -s -w: Omits symbol table and debug information",
			"# Read more about compile flags at https://golang.org/cmd/go/#hdr-Compile_packages_and_dependencies",
			"RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags=\"-s -w\" -a -o ./modules .",
			"",
			"FROM alpine:latest",
			"RUN apk --no-cache add ca-certificates",
			"",
			"# Copy exe from build container",
			"COPY --from=builder /app/modules ./",
			"RUN chmod +x ./modules",
			"",
			"# Define start command",
			"CMD [\"./modules\"]"
		]
	},
	"02-dockerignore": {
		"prefix": "go",
		"body": [
			"Dockerfile",
			".dockerignore",
			"modules",
			"modules.exe"
		]
	},
	"03-structs": {
		"scope": "go",
		"prefix": "go",
		"body": [
			"package main",
			"",
			"import \"fmt\"",
			"",
			"type Point struct {",
			"\tX float64",
			"\tY float64",
			"}",
			"",
			"type Rect struct {",
			"\tLeftUpper, RightLower Point",
			"}",
			"",
			"type Circle struct {",
			"\tCenter Point",
			"\tRadius float64",
			"}",
			"",
			"func main() {",
			"\tp := Point{X: 10, Y: 20}",
			"\tr := Rect{LeftUpper: Point{X: 0, Y: 0}, RightLower: Point{X: 10, Y: 10}}",
			"\tc := Circle{Center: Point{X: 5, Y: 5}, Radius: 5}",
			"",
			"\tfmt.Printf(\"%f, %f, %f\\n\", p.X, r.LeftUpper.X, c.Center.X)",
			"}",
			""
		]
	},
	"04-json-struct": {
		"scope": "go",
		"prefix": "go",
		"body": [
			"// Note [*well-known struct tags*](https://github.com/golang/go/wiki/Well-known-struct-tags#list-of-well-known-struct-tags)",
			"type Point struct {",
			"\tX float64 `json:\"x\"`",
			"\tY float64 `json:\"y\"`",
			"}"
		]
	},
	"05-json-print": {
		"scope": "go",
		"prefix": "go",
		"body": [
			"j, _ := json.Marshal(p)",
			"fmt.Println(string(j))"
		]
	},
	"06-functions": {
		"scope": "go",
		"prefix": "go",
		"body": [
			"func (r Rect) Width() float64 {",
			"\treturn r.RightLower.X - r.LeftUpper.X",
			"}",
			"",
			"func (r Rect) Height() float64 {",
			"\treturn r.RightLower.Y - r.LeftUpper.Y",
			"}",
			"",
			"func (r Rect) Area() float64 {",
			"\treturn float64(r.Width() * r.Height())",
			"}",
			"",
			"func (r *Rect) Enlarge(factor float64) {",
			"\tr.RightLower.X = r.LeftUpper.X + r.Width()*factor",
			"\tr.RightLower.Y = r.LeftUpper.Y + r.Height()*factor",
			"}",
			"",
			"func (c Circle) Area() float64 {",
			"\treturn math.Pi * c.Radius * c.Radius",
			"}"
		]
	},
	"06-functions-call": {
		"scope": "go",
		"prefix": "go",
		"body": [
			"r.Enlarge(2)",
			"fmt.Printf(\"Rectangle's area after enlarging it is %f\\n\", r.Area())"
		]
	},
	"07-interface": {
		"scope": "go",
		"prefix": "go",
		"body": [
			"type Shape interface {",
			"\tArea() float64",
			"}"
		]
	},
	"07-interface-use": {
		"scope": "go",
		"prefix": "go",
		"body": [
			"shapes := []Shape{r, c}",
			"for ix, shape := range shapes {",
			"\tfmt.Printf(\"Area of shape %d (%T) is %f\\n\", ix, shape, shape.Area())",
			"}"
		]
	},
	"08-embedded-struct": {
		"scope": "go",
		"prefix": "go",
		"body": [
			"const (",
			"\tWHITE int = 0xFFFFFF",
			"\tRED   int = 0xFF0000",
			"\tGREEN int = 0x00FF00",
			"\tBLUE  int = 0x0000FF",
			"\tBLACK int = 0x000000",
			")",
			"",
			"type ColoredCircle struct {",
			"\tCircle",
			"\tColor int",
			"}",
			"",
			"func (c ColoredCircle) GetColor() int {",
			"\treturn c.Color",
			"}",
			"",
			"type Colored interface {",
			"\tGetColor() int",
			"}"
		]
	},
	"09-embedded-struct-use": {
		"scope": "go",
		"prefix": "go",
		"body": [
			"// Add colored circle above and add it to shapes",
			"// cc := ColoredCircle{c, RED}",
			"// fmt.Printf(\"Colored circle has radius %f\\n\", cc.Radius)",
			"",
			"if colCirc, ok := shape.(Colored); ok {",
			"\tfmt.Printf(\"\\thas color %x\\n\", colCirc.GetColor())",
			"}"
		]
	},
	"10-pointers": {
		"scope": "go",
		"prefix": "go",
		"body": [
			"package main",
			"",
			"import \"fmt\"",
			"",
			"type person struct {",
			"\tfirstName string",
			"\tlastName string",
			"}",
			"",
			"func main() {",
			"\tx := 42",
			"\tpx := &x",
			"\tfmt.Printf(\"x is at address %v and it's value is %v\\n\", px, *px)",
			"\t",
			"\t*px *= 2",
			"\tfmt.Printf(\"x is at address %v and it's value is %v\\n\", px, *px)",
			"\t",
			"\tpx = new(int)",
			"\tfmt.Printf(\"x is at address %v and it's value is %v\\n\", px, *px)",
			"",
			"\tfunc(val *int) {",
			"\t\t*val = 42",
			"\t}(px)",
			"\tfmt.Printf(\"x is at address %v and it's value is %v\\n\", px, *px)",
			"\t",
			"\tpp := &person{\"Foo\", \"Bar\"}",
			"\tfmt.Printf(\"%s, %s\\n\", pp.lastName, pp.firstName)",
			"\t",
			"\tfunc(somebody *person) {",
			"\t\tsomebody.firstName, somebody.lastName = somebody.lastName, somebody.firstName",
			"\t}(pp)",
			"\tfmt.Printf(\"%s, %s\\n\", pp.lastName, pp.firstName)",
			"}"
		]
	},
	"11-error-return": {
		"scope": "go",
		"prefix": "go",
		"body": [
			"package main",
			"",
			"import (",
			"\t\"errors\"",
			"\t\"fmt\"",
			")",
			"",
			"func div(x int, y int) (int, error) {",
			"\tif y == 0 {",
			"\t\treturn -1, errors.New(\"Sorry, division by zero is not supported\")",
			"\t}",
			"",
			"\treturn x / y, nil",
			"}"
		]
	},
	"12-error-handling": {
		"scope": "go",
		"prefix": "go",
		"body": [
			"func main() {",
			"\tresult, err := div(42, 0)",
			"\tif err != nil {",
			"\t\tfmt.Printf(\"Ups, something bad happened: %s\\n\", err)",
			"\t\treturn",
			"\t}",
			"",
			"\tfmt.Printf(\"The result is %d\\n\", result)",
			"}"
		]
	},
	"12b-panic": {
		"scope": "go",
		"prefix": "go",
		"body": [
			"func div(x int, y int) int {",
			"\tif y == 0 {",
			"\t\tfmt.Println(\"OMG, y is zero, this must NEVER happen, oviously a critical coding error\")",
			"\t\tpanic(\"y == 0\")",
			"\t}",
			"",
			"\treturn x / y",
			"}"
		]
	},
	"12c-defer": {
		"scope": "go",
		"prefix": "go",
		"body": [
			"func repl() {",
			"\tdefer func() {",
			"\t\tif r := recover(); r != nil {",
			"\t\t\tfmt.Println(\"Oh, oh, something bad happend. Shutting down gracefully\")",
			"\t\t\tfmt.Println(r)",
			"\t\t}",
			"\t}()",
			"",
			"\treader := bufio.NewReader(os.Stdin)",
			"\tfor {",
			"\t\tfmt.Print(\"x: \")",
			"\t\txStr, _ := reader.ReadString('\\n')",
			"\t\tfmt.Print(\"y: \")",
			"\t\tyStr, _ := reader.ReadString('\\n')",
			"",
			"\t\tx, _ := strconv.Atoi(xStr[:len(xStr) - 1])",
			"\t\ty, _ := strconv.Atoi(yStr[:len(yStr) - 1])",
			"",
			"\t\tfmt.Printf(\"x / y = %d\\n\", div(x, y))",
			"\t}",
			"}",
			"",
			"func main() {",
			"\trepl()",
			"\tfmt.Println(\"Good bye\")",
			"}"
		]
	},
	"13-start-goroutine": {
		"scope": "go",
		"prefix": "go",
		"body": [
			"package main\r",
			"\r",
			"import (\r",
			"\t\"fmt\"\r",
			"\t\"time\"\r",
			")\r",
			"\r",
			"func sayHello(source string) {\r",
			"\tfmt.Printf(\"Hello World from %s!\\n\", source)\r",
			"\t// time.Sleep(500 * time.Millisecond)\r",
			"}\r",
			"\r",
			"func main() {\r",
			"\tsayHello(\"direct call\")\r",
			"\tgo sayHello(\"goroutine\")\r",
			"\t// go sayHello(\"goroutine\")\r",
			"\r",
			"\ttime.Sleep(10 * time.Millisecond)\r",
			"\t// fmt.Scanln()\r",
			"}\r"
		]
	},
	"13b-goroutine-waitgroup": {
		"scope": "go",
		"prefix": "go",
		"body": [
			"package main\r",
			"\r",
			"import (\r",
			"\t\"fmt\"\r",
			"\t\"time\"\r",
			"\t\"sync\"\r",
			")\r",
			"\r",
			"func sayHello(source string) {\r",
			"\tfmt.Printf(\"Hello World from %s!\\n\", source)\r",
			"\ttime.Sleep(500 * time.Millisecond)\r",
			"}\r",
			"\r",
			"func sayHelloWithWaitgroup(source string, wg *sync.WaitGroup) {\r",
			"\tfmt.Printf(\"Hello World from %s!\\n\", source)\r",
			"\ttime.Sleep(500 * time.Millisecond)\r",
			"\twg.Done()\r",
			"}\r",
			"\r",
			"func main() {\r",
			"\tvar wg sync.WaitGroup\r",
			"\twg.Add(2)\r",
			"\r",
			"\tgo sayHelloWithWaitgroup(\"Hi 1\", &wg)\r",
			"\tgo sayHelloWithWaitgroup(\"Hi 2\", &wg)\r",
			"\r",
			"\twg.Wait()\r",
			"}\r",
			""
		],
		"description": ""
	},
	"14-funcs-channels": {
		"scope": "go",
		"prefix": "go",
		"body": [
			"func getValueAsync(result chan int) {\r",
			"\ttime.Sleep(10 * time.Millisecond)\r",
			"\r",
			"\tfmt.Println(\"Before sending result\")\r",
			"\tresult <- 42\r",
			"\tfmt.Println(\"After sending result\")\r",
			"}\r",
			"\r",
			"func doSomethingComplex(done chan bool) {\r",
			"\ttime.Sleep(10 * time.Millisecond)\r",
			"\r",
			"\t// Try to comment out the next line and see what is going to happen\r",
			"\tdone <- true\r",
			"}\r"
		]
	},
	"15-call-channel": {
		"scope": "go",
		"prefix": "go",
		"body": [
			"// Try adding a capacity in the next line and see what is going to happen\r",
			"result := make(chan int)\r",
			"go getValueAsync(result)\r",
			"// time.Sleep(2000 * time.Millisecond)\r",
			"fmt.Println(\"Before receiving result\")\r",
			"fmt.Println(<-result)\r",
			"fmt.Println(\"After receiving result\")\r",
			"\r",
			"done := make(chan bool)\r",
			"go doSomethingComplex(done)\r",
			"<-done\r",
			"fmt.Println(\"Complex operation is done\")\r"
		]
	},
	"16-select-channel": {
		"scope": "go",
		"prefix": "go",
		"body": [
			"go getValueAsync(result)\r",
			"select {\r",
			"case m := <-result:\r",
			"\tfmt.Println(m)\r",
			"case <-time.After(5 * time.Millisecond):\r",
			"\tfmt.Println(\"timed out\")\r",
			"}\r"
		]
	},
	"17-stdlib-channel": {
		"prefix": "go",
		"body": [
			"ticker := time.NewTicker(100 * time.Millisecond)\r",
			"go func() {\r",
			"\tfor range ticker.C {\r",
			"\t\tfmt.Println(\"Tick\")\r",
			"\t}\r",
			"}()\r",
			"<-time.After(500 * time.Millisecond)\r",
			"ticker.Stop()\r"
		]
	},
	"18-cinterop-puts": {
		"prefix": "go",
		"body": [
			"package main\r",
			"\r",
			"// #include <stdio.h>\r",
			"// #include <stdlib.h>\r",
			"import \"C\"\r",
			"\r",
			"import (\r",
			"\t\"unsafe\"\r",
			")\r",
			"\r",
			"func main() {\r",
			"\tgreeting := C.CString(\"Hello World\")\r",
			"\tdefer C.free(unsafe.Pointer(greeting))\r",
			"\tC.puts(greeting)\r",
			"}\r",
			""
		]
	},
	"19-cinterop-queens": {
		"prefix": "go",
		"body": [
			"package main\r",
			"\r",
			"// #include <stdio.h>\r",
			"// #include <stdlib.h>\r",
			"// #include \"qps.h\"\r",
			"import \"C\"\r",
			"\r",
			"import (\r",
			"\t\"fmt\"\r",
			"\t\"unsafe\"\r",
			")\r",
			"\r",
			"func main() {\r",
			"\tnumberOfSolutions := C.calculateNumberOfSolutions(8)\r",
			"\tfmt.Printf(\"We have found %d solutions\\n\", numberOfSolutions)\r",
			"\r",
			"\tgreeting := C.CString(\"Hello World\")\r",
			"\tdefer C.free(unsafe.Pointer(greeting))\r",
			"\tC.puts(greeting)\r",
			"}\r",
			""
		]
	},
	"20-simple-api": {
		"prefix": "go",
		"body": [
			"package main\r",
			"\r",
			"import (\r",
			"\t\"encoding/json\"\r",
			"\t\"fmt\"\r",
			"\t\"log\"\r",
			"\t\"net/http\"\r",
			"\r",
			"\t\"github.com/gorilla/mux\"\r",
			")\r",
			"\r",
			"type response struct {\r",
			"\tAnswer   uint64 `json:\"answer,omitempty\"`\r",
			"\tGreeting string `json:\"greeting\"`\r",
			"}\r",
			"\r",
			"// our main function\r",
			"func main() {\r",
			"\tvar port uint16 = 8080\r",
			"\r",
			"\t// Setup a simple router\r",
			"\trouter := mux.NewRouter()\r",
			"\r",
			"\t// Setup handler function\r",
			"\trouter.HandleFunc(\"/greet\", greet).Methods(\"GET\")\r",
			"\r",
			"\t// Start server\r",
			"\tfmt.Printf(\"Server starting, will listen to port %d...\\n\", port)\r",
			"\tlog.Fatal(http.ListenAndServe(fmt.Sprintf(\":%d\", port), router))\r",
			"}\r",
			"\r",
			"func greet(w http.ResponseWriter, r *http.Request) {\r",
			"\t// Check query string if answer has been requested\r",
			"\tanswerRequested := len(r.URL.Query().Get(\"withAnswer\")) != 0\r",
			"\r",
			"\t// Build response object\r",
			"\tresp := response{Greeting: \"Hello World\"}\r",
			"\tif answerRequested {\r",
			"\t\tresp.Answer = 42\r",
			"\t}\r",
			"\r",
			"\t// Send back JSON\r",
			"\tjson.NewEncoder(w).Encode(resp)\r",
			"}\r",
			""
		]
	},
	"21-generics-presence": {
		"prefix": "go",
		"body": [
			"package main",
			"",
			"import (",
			"\t\"fmt\"",
			")",
			"",
			"type hero struct {",
			"\tname   string",
			"\tcanFly bool",
			"}",
			"",
			"// Add the required method for the fmt.Stringer interface.",
			"func (h hero) String() string {",
			"\treturn h.name",
			"}",
			"",
			"func main() {",
			"\tvar something interface{} = hero{name: \"Homelander\", canFly: true}",
			"\th, ok := something.(hero) // Use type assertation to check if something is a hero",
			"\tif ok {",
			"\t\tfmt.Println(h.name)",
			"\t}",
			"",
			"\t// Use type assertation to check if something fulfills the",
			"\t// requirements of the fmt.Stringer interface.",
			"\tvar hStringer fmt.Stringer = something.(fmt.Stringer)",
			"\tfmt.Println(hStringer.String())",
			"}"
		]
	},
	"22-generic-function": {
		"prefix": "go",
		"body": [
			"// Use https://go2goplay.golang.org/ go try this code",
			"",
			"package main",
			"",
			"import (",
			"\t\"fmt\"",
			")",
			"",
			"// Print prints all elements of the given slice to stdout",
			"func Print[T any](s []T) {",
			"\tfor _, v := range s {",
			"\t\tfmt.Println(v)",
			"\t}",
			"}",
			"",
			"func main() {",
			"\t// Call print with explicit type parameter",
			"\tPrint[int]([]int{1, 2, 3})",
			"",
			"\t// Let go figure out the type parameter using type inference",
			"\tPrint([]int{1, 2, 3})",
			"}"
		]
	},
	"23-generic-map": {
		"prefix": "go",
		"body": [
			"func Map[T1, T2 any](items []T1, mapFunc func(T1) T2) []T2 {",
			"\tresult := make([]T2, len(items))",
			"\tfor index, item := range items {",
			"\t\tresult[index] = mapFunc(item)",
			"\t}",
			"\treturn result",
			"}",
			"",
			"func main() {",
			"\tPrint(Map([]int{1, 2, 3}, func(item int) bool { return item % 2 == 0 }))",
			"}"
		]
	},
	"24-generic-channels": {
		"prefix": "go",
		"body": [
			"func concat[T any](c1, c2 <-chan T) <-chan T {",
			"\tr := make(chan T)",
			"\tgo func(c1, c2 <-chan T, r chan<- T) {",
			"\t\tdefer close(r)",
			"\t\tfor v := range c1 {",
			"\t\t\tr <- v",
			"\t\t}",
			"\t\t",
			"\t\tfor v := range c2 {",
			"\t\t\tr <- v",
			"\t\t}",
			"\t",
			"\t}(c1, c2, r)",
			"\treturn r",
			"}",
			"",
			"func main() {",
			"\tc1 := make(chan string, 2)",
			"\tc2 := make(chan string, 2)",
			"\t\t",
			"\tgo func() {",
			"\t\tc1 <- \"Hello\"",
			"\t\tc1 <- \", \"",
			"\t\tclose(c1)",
			"\t",
			"\t\tc2 <- \"World\"",
			"\t\tc2 <- \"!\"",
			"\t\tclose(c2)",
			"\t}()",
			"",
			"\tc3 := concat(c1, c2)",
			"\tfor elem := range c3 {",
			"\t\tfmt.Print(elem) // Will result in \"Hello, World!\"",
			"\t}",
			"}"
		]
	},
	"25-generic-constraints": {
		"prefix": "go",
		"body": [
			"type hero struct {",
			"\tname   string",
			"\tcanFly bool",
			"}",
			"",
			"// Add the required method for the fmt.Stringer interface.",
			"func (h hero) String() string {",
			"\treturn h.name",
			"}",
			"",
			"type joiner interface {",
			"\tjoin(string, fmt.Stringer) string",
			"}",
			"",
			"type commaJoiner struct{}",
			"",
			"func (commaJoiner) join(agg string, s fmt.Stringer) string {",
			"\t// This function is for demonstrating generics. It is a",
			"\t// naive implementation of string concatination. In practice,",
			"\t// prefer e.g. strings.Builder to minimize memory copying.",
			"",
			"\tif len(agg) > 0 {",
			"\t\treturn agg + \", \" + s.String();",
			"\t}",
			"",
			"\treturn s.String();",
			"}",
			"",
			"func join[S fmt.Stringer](items []S, j joiner) string {",
			"\tvar result string",
			"\tfor _, item := range items {",
			"\t\t// We can pass `item` to `join()` as the second argument",
			"\t\t// because S has a `fmt.Stringer` constraint.",
			"\t\tresult = j.join(result, item)",
			"\t}",
			"\treturn result",
			"}",
			"",
			"func main() {",
			"\t// Note: hero struct has already been defined in one of the previous samples.",
			"\theroes := []hero{{name: \"Homelander\", canFly: true}, {name: \"Starlight\", canFly: false}}",
			"\tfmt.Print(join(heroes, commaJoiner{}))",
			"}"
		]
	},
	"26-type-list": {
		"prefix": "go",
		"body": [
			"// The adder interface contains datatypes that define the + operator.",
			"type adder interface {",
			"\ttype int, int8, int16, int32, int64,",
			"\t\t uint, uint8, uint16, uint32, uint64,",
			"\t\t float32, float64,",
			"\t\t string",
			"}",
			"",
			"func aggregate[T adder](items []T, seed T) T {",
			"\tresult := seed",
			"\tfor _, item := range items {",
			"\t\t// Generic method can use += because of the type list",
			"\t\t// in the adder constraint.",
			"\t\tresult += item",
			"\t}",
			"\treturn result",
			"}",
			"",
			"// Index fulfills the adder constraint because it's underlying",
			"// type uint is part of adder's type list.",
			"type index uint;",
			"",
			"func main() {",
			"\tfmt.Println(aggregate([]int{1, 2, 3, 4}, 32))  // results in 42",
			"\tfmt.Println(aggregate([]string{\"4\", \"2\"}, \"\")) // results in \"42\"",
			"\tfmt.Println(aggregate([]index{21, 21}, 0))\t // results in 42",
			"",
			"\t// The next line fails because hero cannot satisfy adder",
			"\t// fmt.Println(aggregate([]hero{{name: \"Homelander\", canFly: true},},",
			"\t//\t\t\t\t\t   hero{name: \"Starlight\", canFly: false}))",
			"}"
		]
	},
	"27-generic-types": {
		"prefix": "go",
		"body": [
			"type vectorElement interface {",
			"\ttype int, uint, float32, float64",
			"}",
			"",
			"type vector2d[T vectorElement] struct {",
			"\tX T",
			"\tY T",
			"}",
			"",
			"func newVector2d[T vectorElement](x T, y T) vector2d[T] {",
			"\treturn vector2d[T]{X: x, Y: y};",
			"}",
			"",
			"func (v1 vector2d[T]) add(v2 vector2d[T]) vector2d[T] {",
			"\treturn vector2d[T]{X: v1.X + v2.X, Y: v1.Y + v2.Y}",
			"}",
			"",
			"func main() {",
			"\tv1 := newVector2d(10, 10)",
			"\tv2 := newVector2d(11, 11)",
			"\tv3 := v1.add(v2)",
			"\tfmt.Println(v3)",
			"}"
		]
	},
	"28-generic-iterator": {
		"prefix": "go",
		"body": [
			"// Use https://go2goplay.golang.org/ go try this code",
			"",
			"package main",
			"",
			"import (",
			"\t\"fmt\"",
			"\t\"strings\"",
			")",
			"",
			"// Generic iterator function type",
			"type iteratorFunc[T any] func() *T;",
			"",
			"// Generic function for iteration",
			"func next[T any](iterator iteratorFunc[T]) *T { return iterator() }",
			"",
			"// Generic function executing a given function for each item in iterator",
			"func forEach[T any](iterator iteratorFunc[T], body func(T)) {",
			"\tfor ptr := next(iterator); ptr != nil; ptr = next(iterator) {",
			"\t\tbody(*ptr)",
			"\t}",
			"}",
			"",
			"// Generic predicate",
			"type predicate[T any] func(item T) bool;",
			"",
			"// Generic function filtering based on a given predicate",
			"func filter[T any](iterator iteratorFunc[T], predicate func(T) bool) iteratorFunc[T] {",
			"\treturn func() *T {",
			"\t\tvar item *T",
			"\t\tfor item = next(iterator); item != nil && !predicate(*item); item = next(iterator) { }",
			"\t\treturn item",
			"\t}",
			"}",
			"",
			"// Generic function that generates an iterator from a given slice",
			"func iteratorFromSlice[T any](items []T) iteratorFunc[T] {",
			"\treturn func() *T {",
			"\t\tif len(items) < 1 {",
			"\t\t\treturn nil",
			"\t\t}",
			"\t\t",
			"\t\tfirstItem := &items[0]",
			"\t\titems = items[1:]",
			"\t\treturn firstItem",
			"\t}",
			"}",
			"",
			"type user struct {",
			"\tname string",
			"\tage  int",
			"}",
			"",
			"func numbersIterator(max int) iteratorFunc[int] {",
			"\tcurrent := 0;",
			"\treturn func() *int {",
			"\t\tif (current >= max) {",
			"\t\t\treturn nil",
			"\t\t}",
			"\t\t",
			"\t\tresult := current",
			"\t\tcurrent++",
			"\t\treturn &result",
			"\t}",
			"}",
			"",
			"func main() {",
			"\tusers := []user{",
			"\t\tuser{name: \"Foo\", age: 42}, ",
			"\t\tuser{name: \"Bar\", age: 43}, ",
			"\t\tuser{name: \"FooBar\", age: 44}, ",
			"\t}",
			"",
			"\t// Print each user's name where the user name starts with Foo.",
			"\tforEach(",
			"\t\tfilter(",
			"\t\t\titeratorFromSlice(users),",
			"\t\t\tfunc(u user) bool { return strings.HasPrefix(u.name, \"Foo\"); }),",
			"\t\tfunc(u user) { fmt.Printf(\"User is %s\\n\", u.name) })",
			"",
			"\t// Print even numbers between 0 and 10 (excl.)",
			"\tforEach(",
			"\t\tfilter(",
			"\t\t\tnumbersIterator(10),",
			"\t\t\tfunc(n int) bool { return n % 2 == 0 }),",
			"\t\tfunc(n int) { fmt.Println(n) })",
			"}"
		]
	}
}